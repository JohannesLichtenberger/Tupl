/*
 *  Copyright (C) 2022 Cojen.org
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package org.cojen.tupl.rows;

import java.lang.invoke.CallSite;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;

import java.lang.ref.WeakReference;

import java.util.Map;

import org.cojen.maker.ClassMaker;
import org.cojen.maker.Label;
import org.cojen.maker.MethodMaker;
import org.cojen.maker.Variable;

import org.cojen.tupl.Cursor;
import org.cojen.tupl.DatabaseException;
import org.cojen.tupl.Index;
import org.cojen.tupl.LockResult;
import org.cojen.tupl.Transaction;

import org.cojen.tupl.core.RowPredicateLock;

/**
 * Makes Table classes which dynamically generates code which depends on RowStore and tableId
 * constants. The generated classes extend those generated by StaticTableMaker.
 *
 * @author Brian S O'Neill
 */
public class DynamicTableMaker extends TableMaker {
    private final RowStore mStore;
    private final long mTableId;

    private final Class mBaseClass;

    /**
     * Constructor for making a primary table.
     *
     * @param rowGen describes row encoding
     * @param store generated class is pinned to this specific instance
     * @param tableId primary table index id
     */
    DynamicTableMaker(Class<?> type, RowGen rowGen, RowStore store, long tableId) {
        super(type, rowGen, rowGen, null);

        mStore = store;
        mTableId = tableId;

        mBaseClass = StaticTableMaker.obtain(type, rowGen);
    }

    /**
     * Constructor for making an unjoined secondary index table.
     *
     * @param rowGen describes row encoding
     * @param codecGen describes key and value codecs (different than rowGen)
     * @param secondaryDesc secondary index descriptor
     * @param store generated class is pinned to this specific instance
     * @param tableId primary table index id
     */
    DynamicTableMaker(Class<?> type, RowGen rowGen, RowGen codecGen, byte[] secondaryDesc,
                      RowStore store, long tableId)
    {
        super(type, rowGen, codecGen, secondaryDesc);

        mStore = store;
        mTableId = tableId;

        mBaseClass = StaticTableMaker.obtain(type, rowGen, secondaryDesc);
    }

    /**
     * Return a constructor which accepts a (TableManager, Index, RowPredicateLock) and returns
     * a BaseTable or BaseTableIndex implementation.
     */
    MethodHandle finish() {
        String suffix = isPrimaryTable() ? "table" : "unjoined";
        mClassMaker = mCodecGen.beginClassMaker(getClass(), mRowType, suffix).public_()
            .extend(mBaseClass);

        MethodType mt = MethodType.methodType
            (void.class, TableManager.class, Index.class, RowPredicateLock.class);

        MethodMaker ctor = mClassMaker.addConstructor(mt);
        ctor.invokeSuperConstructor(ctor.param(0), ctor.param(1), ctor.param(2));

        if (isPrimaryTable()) {
            addDynamicEncodeValueColumns();
            addDynamicDecodeValueColumns();

            // Override the inherited abstract delegate methods to call the static methods
            // defined above.

            MethodMaker mm = mClassMaker.addMethod
                (byte[].class, "doEncodeValue", mRowClass).protected_();
            mm.return_(mm.invoke("encodeValue", mm.param(0)));

            mm = mClassMaker.addMethod
                (null, "doDecodeValue", mRowClass, byte[].class).protected_();

            addDynamicUpdateValueColumns();
            addDoUpdateMethod();

            mm.invoke("decodeValue", mm.param(0), mm.param(1));
        }

        addUnfilteredMethods();

        return doFinish(mt);
    }

    /**
     * Implements: static byte[] encodeValue(RowClass row)
     *
     * Method isn't implemented until needed, delaying acquisition/creation of the current
     * schema version. This allows replicas to decode existing rows even when the class
     * definition has changed, but encoding will still fail.
     */
    private void addDynamicEncodeValueColumns() {
        MethodMaker mm = mClassMaker.addMethod(byte[].class, "encodeValue", mRowClass).static_();
        var indy = mm.var(DynamicTableMaker.class).indy
            ("indyEncodeValueColumns", mStore.ref(), mRowType, mTableId);
        mm.return_(indy.invoke(byte[].class, "encodeValue", null, mm.param(0)));
    }

    public static CallSite indyEncodeValueColumns
        (MethodHandles.Lookup lookup, String name, MethodType mt,
         WeakReference<RowStore> storeRef, Class<?> rowType, long tableId)
    {
        return doIndyEncode
            (lookup, name, mt, storeRef, rowType, tableId, (mm, info, schemaVersion) -> {
                ColumnCodec[] codecs = info.rowGen().valueCodecs();
                addEncodeColumns(mm, ColumnCodec.bind(schemaVersion, codecs, mm));
            });
    }

    /**
     * Implements: static byte[] updateValue(RowClass row, byte[] original)
     *
     * Method isn't fully implemented until needed, delaying acquisition/creation of the
     * current schema version. This allows replicas to decode existing rows even when the class
     * definition has changed, but encoding will still fail.
     */
    private void addDynamicUpdateValueColumns() {
        MethodMaker mm = mClassMaker
            .addMethod(byte[].class, "updateValue", mRowClass, byte[].class).static_();

        if (mCodecGen.info.valueColumns.isEmpty()) {
            // If the checkValueAllDirty method was defined, it would always return true.
            mm.return_(mm.var(RowUtils.class).field("EMPTY_BYTES"));
            return;
        }

        Variable rowVar = mm.param(0);

        Label partiallyDirty = mm.label();
        mm.invoke("checkValueAllDirty", rowVar).ifFalse(partiallyDirty);
        mm.return_(mm.invoke("encodeValue", rowVar));
        partiallyDirty.here();

        var indy = mm.var(DynamicTableMaker.class).indy
            ("indyUpdateValueColumns", mStore.ref(), mRowType, mTableId);
        mm.return_(indy.invoke(byte[].class, "updateValue", null, rowVar, mm.param(1)));
    }

    public static CallSite indyUpdateValueColumns
        (MethodHandles.Lookup lookup, String name, MethodType mt,
         WeakReference<RowStore> storeRef, Class<?> rowType, long tableId)
    {
        return doIndyEncode
            (lookup, name, mt, storeRef, rowType, tableId, (mm, info, schemaVersion) -> {
                if (schemaVersion == 0 || info.valueColumns.isEmpty()) {
                    // Not expected, but handle it nonetheless.
                    mm.return_(mm.var(RowUtils.class).field("EMPTY_BYTES"));
                    return;
                }

                // These variables were provided by the indy call in addDynamicUpdateValueColumns.
                Variable rowVar = mm.param(0);
                Variable originalVar = mm.param(1); // byte[]

                var tableVar = mm.var(lookup.lookupClass());
                var ue = encodeUpdateEntry(mm, info, schemaVersion, tableVar, rowVar, originalVar);

                mm.return_(ue.newEntryVar);
            });
    }

    @FunctionalInterface
    static interface EncodeFinisher {
        void finish(MethodMaker mm, RowInfo info, int schemaVersion);
    }

    /**
     * Does the work to obtain the current schema version, handling any exceptions. The given
     * finisher completes the definition of the encode method when no exception was thrown when
     * trying to obtain the schema version. If an exception was thrown, the finisher might be
     * called at a later time.
     */
    private static CallSite doIndyEncode(MethodHandles.Lookup lookup, String name, MethodType mt,
                                         WeakReference<RowStore> storeRef,
                                         Class<?> rowType, long tableId,
                                         EncodeFinisher finisher)
    {
        return ExceptionCallSite.make(() -> {
            MethodMaker mm = MethodMaker.begin(lookup, name, mt);
            RowStore store = storeRef.get();
            if (store == null) {
                mm.new_(DatabaseException.class, "Closed").throw_();
            } else {
                RowInfo info = RowInfo.find(rowType);
                int schemaVersion;
                try {
                    schemaVersion = store.schemaVersion(info, false, tableId, true);
                } catch (Exception e) {
                    return new ExceptionCallSite.Failed(mt, mm, e);
                }
                finisher.finish(mm, info, schemaVersion);
            }
            return mm.finish();
        });
    }

    private void addDynamicDecodeValueColumns() {
        // First define a method which generates the SwitchCallSite.
        {
            MethodMaker mm = mClassMaker.addMethod
                (SwitchCallSite.class, "decodeValueSwitchCallSite").static_();
            var condy = mm.var(DynamicTableMaker.class).condy
                ("condyDecodeValueColumns",  mStore.ref(), mRowType, mRowClass, mTableId);
            mm.return_(condy.invoke(SwitchCallSite.class, "_"));
        }

        // Also define a method to obtain a MethodHandle which decodes for a given schema
        // version. This must be defined here to ensure that the correct lookup is used. It
        // must always refer to this table class.
        {
            MethodMaker mm = mClassMaker.addMethod
                (MethodHandle.class, "decodeValueHandle", int.class).static_();
            var lookup = mm.var(MethodHandles.class).invoke("lookup");
            var mh = mm.invoke("decodeValueSwitchCallSite").invoke("getCase", lookup, mm.param(0));
            mm.return_(mh);
        }

        MethodMaker mm = mClassMaker.addMethod
            (null, "decodeValue", mRowClass, byte[].class).static_().public_();

        var data = mm.param(1);
        var schemaVersion = mm.var(RowUtils.class).invoke("decodeSchemaVersion", data);

        var indy = mm.var(DynamicTableMaker.class).indy("indyDecodeValueColumns");
        indy.invoke(null, "decodeValue", null, schemaVersion, mm.param(0), data);
    }

    /**
     * Returns a SwitchCallSite instance suitable for decoding all value columns. By defining
     * it via a "condy" method, the SwitchCallSite instance can be shared by other methods. In
     * particular, filter subclasses are generated against specific schema versions, and so
     * they need direct access to just one of the cases. This avoids a redundant version check.
     *
     * MethodType is: void (int schemaVersion, RowClass row, byte[] data)
     */
    public static SwitchCallSite condyDecodeValueColumns
        (MethodHandles.Lookup lookup, String name, Class<?> type,
         WeakReference<RowStore> storeRef, Class<?> rowType, Class<?> rowClass, long tableId)
    {
        MethodType mt = MethodType.methodType(void.class, int.class, rowClass, byte[].class);

        return new SwitchCallSite(lookup, mt, schemaVersion -> {
            MethodMaker mm = MethodMaker.begin(lookup, null, "case", rowClass, byte[].class);

            RowStore store = storeRef.get();
            if (store == null) {
                mm.new_(DatabaseException.class, "Closed").throw_();
            } else {
                RowInfo dstRowInfo = RowInfo.find(rowType);

                if (schemaVersion == 0) {
                    // No columns to decode, so assign defaults.
                    for (Map.Entry<String, ColumnInfo> e : dstRowInfo.valueColumns.entrySet()) {
                        Converter.setDefault(mm, e.getValue(), mm.param(0).field(e.getKey()));
                    }
                } else {
                    RowInfo srcRowInfo;
                    try {
                        srcRowInfo = store.rowInfo(rowType, tableId, schemaVersion);
                    } catch (Exception e) {
                        return new ExceptionCallSite.Failed
                            (MethodType.methodType(void.class, rowClass, byte[].class), mm, e);
                    }

                    ColumnCodec[] srcCodecs = srcRowInfo.rowGen().valueCodecs();
                    int fixedOffset = schemaVersion < 128 ? 1 : 4;

                    addDecodeColumns(mm, dstRowInfo, srcCodecs, fixedOffset);

                    if (dstRowInfo != srcRowInfo) {
                        // Assign defaults for any missing columns.
                        for (Map.Entry<String, ColumnInfo> e : dstRowInfo.valueColumns.entrySet()) {
                            String fieldName = e.getKey();
                            if (!srcRowInfo.valueColumns.containsKey(fieldName)) {
                                Converter.setDefault
                                    (mm, e.getValue(), mm.param(0).field(fieldName));
                            }
                        }
                    }
                }
            }

            return mm.finish();
        });
    }

    /**
     * This just returns the SwitchCallSite generated by condyDecodeValueColumns.
     */
    public static SwitchCallSite indyDecodeValueColumns(MethodHandles.Lookup lookup,
                                                        String name, MethodType mt)
        throws Throwable
    {
        MethodHandle mh = lookup.findStatic(lookup.lookupClass(), "decodeValueSwitchCallSite",
                                            MethodType.methodType(SwitchCallSite.class));
        return (SwitchCallSite) mh.invokeExact();
    }

    /**
     * Adds a method which does most of the work for the update and merge methods. The
     * transaction parameter must not be null, which is committed when changes are made.
     *
     *     boolean doUpdate(Transaction txn, ActualRow row, boolean merge);
     */
    private void addDoUpdateMethod() {
        // Override the inherited abstract method.
        MethodMaker mm = mClassMaker.addMethod
            (boolean.class, "doUpdate", Transaction.class, mRowClass, boolean.class).protected_();

        Variable txnVar = mm.param(0);
        Variable rowVar = mm.param(1);
        Variable mergeVar = mm.param(2);

        Label ready = mm.label();
        mm.invoke("checkPrimaryKeySet", rowVar).ifTrue(ready);
        mm.new_(IllegalStateException.class, "Primary key isn't fully specified").throw_();

        ready.here();

        final var keyVar = mm.invoke("encodePrimaryKey", rowVar);
        final var source = mm.field("mSource");
        final var cursorVar = source.invoke("newCursor", txnVar);

        Label cursorStart = mm.label().here();

        // If all value columns are dirty, replace the whole row and commit.
        {
            Label cont;
            if (mCodecGen.info.valueColumns.isEmpty()) {
                // If the checkValueAllDirty method was defined, it would always return true.
                cont = null;
            } else {
                cont = mm.label();
                mm.invoke("checkValueAllDirty", rowVar).ifFalse(cont);
            }

            final Variable triggerVar;
            final Label triggerStart;

            if (!supportsTriggers()) {
                triggerVar = null;
                triggerStart = null;
            } else {
                triggerVar = mm.var(Trigger.class);
                Label skipLabel = mm.label();
                prepareForTrigger(mm, mm.this_(), triggerVar, skipLabel);
                triggerStart = mm.label().here();

                cursorVar.invoke("find", keyVar);
                var oldValueVar = cursorVar.invoke("value");
                Label replace = mm.label();
                oldValueVar.ifNe(null, replace);
                mm.return_(false);
                replace.here();
                var valueVar = mm.invoke("encodeValue", rowVar);
                triggerVar.invoke("store", txnVar, rowVar, keyVar, oldValueVar, valueVar);
                cursorVar.invoke("commit", valueVar);
                markAllClean(rowVar);
                mm.return_(true);

                skipLabel.here();
            }

            cursorVar.invoke("autoload", false);
            cursorVar.invoke("find", keyVar);
            Label replace = mm.label();
            cursorVar.invoke("value").ifNe(null, replace);
            mm.return_(false);
            replace.here();
            cursorVar.invoke("commit", mm.invoke("encodeValue", rowVar));

            if (triggerStart != null) {
                mm.finally_(triggerStart, () -> triggerVar.invoke("releaseShared"));
            }

            markAllClean(rowVar);
            mm.return_(true);

            if (cont == null) {
                return;
            }

            cont.here();
        }

        cursorVar.invoke("find", keyVar);

        Label hasValue = mm.label();
        cursorVar.invoke("value").ifNe(null, hasValue);
        mm.return_(false);
        hasValue.here();

        // The bulk of the method isn't implemented until needed, delaying acquisition/creation
        // of the current schema version.

        var indy = mm.var(DynamicTableMaker.class).indy
            ("indyDoUpdate", mStore.ref(), mRowType, mTableId, supportsTriggers() ? 1 : 0);
        indy.invoke(null, "doUpdate", null, mm.this_(), rowVar, mergeVar, cursorVar);
        mm.return_(true);

        mm.finally_(cursorStart, () -> cursorVar.invoke("reset"));
    }

    /**
     * @param triggers 0 for false, 1 for true
     */
    public static CallSite indyDoUpdate(MethodHandles.Lookup lookup, String name, MethodType mt,
                                        WeakReference<RowStore> storeRef,
                                        Class<?> rowType, long tableId, int triggers)
    {
        return doIndyEncode
            (lookup, name, mt, storeRef, rowType, tableId, (mm, info, schemaVersion) -> {
                finishIndyDoUpdate(mm, info, schemaVersion, triggers);
            });
    }

    /**
     * @param triggers 0 for false, 1 for true
     */
    private static void finishIndyDoUpdate(MethodMaker mm, RowInfo rowInfo, int schemaVersion,
                                           int triggers)
    {
        // All these variables were provided by the indy call in addDoUpdateMethod.
        Variable tableVar = mm.param(0);
        Variable rowVar = mm.param(1);
        Variable mergeVar = mm.param(2);
        Variable cursorVar = mm.param(3);

        Variable valueVar = cursorVar.invoke("value");

        var ue = encodeUpdateEntry(mm, rowInfo, schemaVersion, tableVar, rowVar, valueVar);
        Variable newValueVar = ue.newEntryVar;
        Variable[] offsetVars = ue.offsetVars;

        if (triggers == 0) {
            cursorVar.invoke("commit", newValueVar);
        }

        Label doMerge = mm.label();
        mergeVar.ifTrue(doMerge);

        if (triggers != 0) {
            var triggerVar = mm.var(Trigger.class);
            Label skipLabel = mm.label();
            prepareForTrigger(mm, tableVar, triggerVar, skipLabel);
            Label triggerStart = mm.label().here();

            var txnVar = cursorVar.invoke("link");
            var keyVar = cursorVar.invoke("key");
            triggerVar.invoke("storeP", txnVar, rowVar, keyVar, valueVar, newValueVar);
            cursorVar.invoke("commit", newValueVar);
            Label cont = mm.label().goto_();

            skipLabel.here();

            cursorVar.invoke("commit", newValueVar);

            mm.finally_(triggerStart, () -> triggerVar.invoke("releaseShared"));

            cont.here();
        }

        markAllUndirty(rowVar, rowInfo);
        mm.return_();

        doMerge.here();

        // Decode all the original column values that weren't updated into the row.

        RowGen rowGen = rowInfo.rowGen();
        Map<String, Integer> columnNumbers = rowGen.columnNumbers();
        ColumnCodec[] codecs = ColumnCodec.bind(rowGen.valueCodecs(), mm);

        String stateFieldName = null;
        Variable stateField = null;

        for (int i=0; i<codecs.length; i++) {
            ColumnCodec codec = codecs[i];
            ColumnInfo info = codec.mInfo;
            int num = columnNumbers.get(info.name);

            String sfName = rowGen.stateField(num);
            if (!sfName.equals(stateFieldName)) {
                stateFieldName = sfName;
                stateField = rowVar.field(stateFieldName).get();
            }

            int sfMask = RowGen.stateFieldMask(num);
            Label cont = mm.label();
            stateField.and(sfMask).ifEq(sfMask, cont);

            codec.decode(rowVar.field(info.name), valueVar, offsetVars[i], null);

            cont.here();
        }

        if (triggers != 0) {
            var triggerVar = mm.var(Trigger.class);
            Label skipLabel = mm.label();
            prepareForTrigger(mm, tableVar, triggerVar, skipLabel);
            Label triggerStart = mm.label().here();

            var txnVar = cursorVar.invoke("link");
            var keyVar = cursorVar.invoke("key");
            triggerVar.invoke("store", txnVar, rowVar, keyVar, valueVar, newValueVar);
            cursorVar.invoke("commit", newValueVar);
            Label cont = mm.label().goto_();

            skipLabel.here();

            cursorVar.invoke("commit", newValueVar);

            mm.finally_(triggerStart, () -> triggerVar.invoke("releaseShared"));

            cont.here();
        }

        markAllClean(rowVar, rowGen, rowGen);
    }

    /**
     * Defines methods which return a SingleScanController instance.
     */
    private void addUnfilteredMethods() {
        MethodMaker mm = mClassMaker.addMethod
            (SingleScanController.class, "unfiltered").protected_();
        var condyClass = mm.var(DynamicTableMaker.class).condy
            ("condyDefineUnfiltered", mRowType, mRowClass, mTableId, mSecondaryDescriptor);
        var scanControllerCtor = condyClass.invoke(MethodHandle.class, "unfiltered");
        Class<?>[] paramTypes = {
            byte[].class, boolean.class, byte[].class, boolean.class, boolean.class
        };
        mm.return_(scanControllerCtor.invoke
                   (SingleScanController.class, "invokeExact", paramTypes,
                    null, false, null, false, false));

        mm = mClassMaker.addMethod(SingleScanController.class, "unfilteredReverse").protected_();
        // Use the same scanControllerCtor constant, but must set against the correct maker.
        scanControllerCtor = mm.var(MethodHandle.class).set(scanControllerCtor);
        mm.return_(scanControllerCtor.invoke
                   (SingleScanController.class, "invokeExact", paramTypes,
                    null, false, null, false, true));
    }

    /**
     * Makes a subclass of SingleScanController with matching constructors.
     *
     * @param secondaryDesc pass null for primary table
     * @return the basic constructor handle
     */
    public static MethodHandle condyDefineUnfiltered
        (MethodHandles.Lookup lookup, String name, Class type,
         Class rowType, Class rowClass, long tableId, byte[] secondaryDesc)
        throws Throwable
    {
        RowInfo rowInfo = RowInfo.find(rowType);
        RowGen rowGen = rowInfo.rowGen();
        RowGen codecGen = rowGen;

        if (secondaryDesc != null) {
            codecGen = RowStore.secondaryRowInfo(rowInfo, secondaryDesc).rowGen();
        }

        ClassMaker cm = RowGen.beginClassMaker
            (DynamicTableMaker.class, rowType, rowInfo, null, name)
            .extend(SingleScanController.class).public_();

        // Constructors are protected, for use by filter implementation subclasses.
        final MethodType ctorType;
        {
            ctorType = MethodType.methodType(void.class, byte[].class, boolean.class,
                                             byte[].class, boolean.class, boolean.class);
            MethodMaker mm = cm.addConstructor(ctorType).protected_();
            mm.invokeSuperConstructor
                (mm.param(0), mm.param(1), mm.param(2), mm.param(3), mm.param(4));

            // Define a reverse scan copy constructor.
            mm = cm.addConstructor(SingleScanController.class).protected_();
            mm.invokeSuperConstructor(mm.param(0));
        }

        // Specified by RowEvaluator.
        cm.addMethod(long.class, "tableId").public_().final_().return_(tableId);

        if (secondaryDesc != null) {
            // Specified by RowEvaluator.
            MethodMaker mm = cm.addMethod(byte[].class, "secondaryDescriptor").public_();
            mm.return_(mm.var(byte[].class).setExact(secondaryDesc));
        }

        {
            // Specified by RowEvaluator.
            MethodMaker mm = cm.addMethod
                (Object.class, "evalRow", Cursor.class, LockResult.class, Object.class).public_();

            final var cursorVar = mm.param(0);
            final var keyVar = cursorVar.invoke("key");
            final var valueVar = cursorVar.invoke("value");
            final var rowVar = mm.param(2);

            final Label notRow = mm.label();
            final var typedRowVar = CodeUtils.castOrNew(rowVar, rowClass, notRow);

            var tableVar = mm.var(lookup.lookupClass());
            tableVar.invoke("decodePrimaryKey", typedRowVar, keyVar);
            tableVar.invoke("decodeValue", typedRowVar, valueVar);
            markAllClean(typedRowVar, rowGen, codecGen);
            mm.return_(typedRowVar);

            // Assume the passed in row is actually a RowConsumer.
            notRow.here();
            CodeUtils.acceptAsRowConsumerAndReturn(rowVar, rowClass, keyVar, valueVar);
        }

        {
            // Specified by RowEvaluator.
            MethodMaker mm = cm.addMethod
                (Object.class, "decodeRow", Object.class, byte[].class, byte[].class).public_();
            var rowVar = CodeUtils.castOrNew(mm.param(0), rowClass);
            var tableVar = mm.var(lookup.lookupClass());
            tableVar.invoke("decodePrimaryKey", rowVar, mm.param(1));
            tableVar.invoke("decodeValue", rowVar, mm.param(2));
            markAllClean(rowVar, rowGen, codecGen);
            mm.return_(rowVar);
        }

        {
            // Specified by RowEvaluator.
            MethodMaker mm = cm.addMethod
                (byte[].class, "updateKey", Object.class, byte[].class).public_();
            var rowVar = mm.param(0).cast(rowClass);
            var tableVar = mm.var(lookup.lookupClass());
            Label unchanged = mm.label();
            tableVar.invoke("checkPrimaryKeyAnyDirty", rowVar).ifFalse(unchanged);
            mm.return_(tableVar.invoke("updatePrimaryKey", rowVar, mm.param(1)));
            unchanged.here();
            mm.return_(null);
        }

        {
            // Specified by RowEvaluator.
            MethodMaker mm = cm.addMethod
                (byte[].class, "updateValue", Object.class, byte[].class).public_();
            var rowVar = mm.param(0).cast(rowClass);
            var tableVar = mm.var(lookup.lookupClass());
            mm.return_(tableVar.invoke("updateValue", rowVar, mm.param(1)));
        }

        if (rowGen == codecGen) { // isPrimaryTable, so a schema must be decoded
            // Used by filter subclasses. The int param is the schema version.
            MethodMaker mm = cm.addMethod
                (MethodHandle.class, "decodeValueHandle", int.class).protected_().static_();
            var tableVar = mm.var(lookup.lookupClass());
            mm.return_(tableVar.invoke("decodeValueHandle", mm.param(0)));
        }

        lookup = cm.finishLookup();

        MethodHandle mh = lookup.findConstructor(lookup.lookupClass(), ctorType);

        return mh.asType(mh.type().changeReturnType(SingleScanController.class));
    }
}
