/*
 *  Copyright 2012 Brian S O'Neill
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package org.cojen.tupl;

import java.io.IOException;

/**
 * 
 *
 * @author Brian S O'Neill
 */
public interface ReplicationManager {
    // FIXME: Master is allowed to read from any position, but EOF is returned
    // if no more. This allows master to switch to temporary replica mode if
    // transaction commit times out. When commit times out, how far to
    // rollback?  Transactions known to have already committed cannot be
    // re-committed -- or can they? If all operations are applied, then it
    // should be idempotent, but an intermediate blip will be observed. This is
    // bad. Perhaps all reads are locked out until recovery completes? There's
    // currently no way to do this. After reading EOF, all in-flight
    // transactions are rolled back. Since they all need to be tracked anyhow,
    // one way to prevent duplication of transactions is to simply ignore those
    // that aren't currently being tracked. Assume they committed just fine (or
    // explicitly rolled back) and skip them. Transaction log needs explicit
    // messages (generated by master) when leadership changes. This is
    // necessary for recovery to know when to stop assuming transactions will
    // commit. They all rollback when observing the special message.

    /**
     * Indicates that all data prior to the given log position has been durably
     * checkpointed. The log can discard the old data. This method is never
     * invoked concurrently, and the implementation should return quickly.
     *
     * @param position log position immediately after the checkpoint position
     */
    //void checkpointed(long position) throws IOException;

    /**
     * Instruct that all data starting at the given position must be deleted.
     */
    //void truncate(long position) throws IOException;

    /**
     * Provides a stream for a replica to read from, blocking until more data
     * arrives. Upon becoming the replication master, the stream returns
     * -1 and must be discarded. This method and the stream are never invoked
     * concurrently.
     *
     * @param position log position to start reading from
     * @return can be null if local instance is the master
     */
    Input in(long position) throws IOException;

    /**
     * Provides a stream for the master to write into. Upon losing the
     * master role, the stream returns false and must be discarded. This method
     * and the stream are never invoked concurrently.
     *
     * @param position log position to start writing to
     * @return can be null if local instance is not the master
     */
    Output out(long position) throws IOException;

    /**
     * Forward a change from a replica to the master. Change must arrive back
     * through the input stream. This method can be invoked concurrently by
     * multiple threads.
     *
     * @return false if local instance is not a replica or if no master has
     * been established
     */
    //boolean forward(byte[] b, int off, int len) throws IOException;

    /**
     * 
     */
    static interface Input {
        /**
         * Blocks at most once, reading as much replication input as
         * possible. Returns -1 if local instance has become the master.
         *
         * @return amount read, or -1 if master
         */
        int read(byte[] b, int off, int len) throws IOException;
    }

    /**
     * 
     */
    static interface Output {
        /**
         * Fully writes the given data, blocking until complete. Returns false
         * if local instance if not the master.
         *
         * @return true if written; false if not master
         */
        boolean write(byte[] b, int off, int len) throws IOException;

        /**
         * Durably flushes all modifications to local non-volatile storage.
         *
         * @return true if written; false if not master
         */
        boolean sync(long position) throws IOException;

        /**
         * Blocks until all data up to the given log position is confirmed.
         * Returns false if local instance if not the master or if operation
         * timed out.
         *
         * @return true if confirmed; false if not master or timed out
         */
        boolean confirm(long position, long timeoutNanos) throws IOException;
    }
}
