
- Use 6-byte pointers in internal nodes.
- Support key prefix compression.
- Support closing indexes. Requires latch sweep and stubbing of cursors.
- Support truncating indexes. Depends on close and workflow to ensure truncate completes.
- Online compaction. Two types: Node merging and file truncation. File
  truncation is the more difficult one.
- Support snapshot into a temp Database instance.
- Add Index.insertFence and removeFence methods for boosting findNearby
  performance at the edges. Implementation inserts a tombstone.


Reduce overhead of checkpoint by sweeping through dirty nodes twice. This
approach smooths out the "bump" when issuing a checkpoint. Also, it allows
dirty nodes to move to MRU position when accessed. A new state is introduced,
"mutable". At checkpoint, sweep through all dirty nodes, write them out, and
mark them as mutable. When a mutable node is altered, its state becomes dirty
again, but it doesn't acquire a new identifier. After first checkpoint sweep,
switch active state (0/1). All dirty nodes with old state are written first
when modified, just like the current design. Mutable nodes with old state don't
need to be written, but a new identifier must still be acquired. Checkpoint now
sweeps through node list again, forcing all dirty nodes to be written and
marked clean. Those which are mutable are also marked clean, but without the
additional write.

Shared commit lock is held for a long time, especially when a fragmented value
is being created. When the checkpointer requests an exclusive lock, all other
requests for the shared lock are blocked. Introduce a new type of lock, which
is hooked into the FileIO or PageArray class. When an I/O operation is
performed, assume it will take a long time and allow any shared lock waiters to
barge ahead of the exclusive lock request.

---
